import numpy as np
import random


# Transform our elements from binary to decimal (using the first bit to define the sign of the number

def ma2vec(m, d):
    x = []
    for i in range(d):
        t = 0
        tt = 0
        if m[i][0] == 0:
            for j in m[i]:
                if tt == 0:
                    tt = 1
                    continue
                t *= 2
                t += j
            t-=pow(2,d)
            #print(d)
        else:
            for j in m[i]:
                if tt == 0:
                    tt = 1
                    continue
                t *= 2
                t += j
            #t = -t
        x.append(t)
    x = np.array(x)
    return x


# function f(x) = x^TAx + b^Tx + c, also the fitness function
def func(a, b, c, po, d):
    x = ma2vec(po, d)
    temp = np.matmul(x.transpose(), a)
    xax = np.matmul(temp, x)
    bx = np.matmul(b.transpose(), x)
    ans = c + bx + xax
    return ans


def user_inputs():
    dim = input('Give function dimensionality: ');
    dim = int(dim)
    print('Give matrix A (each row you add press Enter) : ')
    a = [[0 for i in range(dim)] for j in range(dim)]
    i = 0
    while i < dim:
        a[i] = list(map(int, input().split()))
        i += 1
    a = np.array(a)
    b = list(map(int, input("Give d-dimensional vector b: ").split()));
    b = np.array(b)
    c = input('Give constant c: ');
    c = int(c)
    d = int(input('Give the range of searched integers as 𝑑≥1 that for each dimension i, −2^d<xi<2^d: '))
    psize = int(input('Give population size: '));
    pairs = psize // 2
    pcr = float(input('Give crossover probability: '))
    while pcr < 0 or pcr > 1:
        pcr = float(input('Give correct crossover probability (in range (0,1)) : '))
    pmu = float(input('Give mutation probability: '))
    while pmu < 0 or pmu > 1:
        pmu = float(input('Give correct mutation probability (in range(0,1)): '))
    ite = int(input('Give number of iterations: '))
    repl = int(input('How many individuals to replace in each iteration? '))
    while repl < 0 or repl > psize:
        repl = int(input('Give correct replacement number (in range(0,psize)): '))
    return dim, a, b, c, d, psize, pcr, pmu, ite, repl, pairs


def mutation(psize, pop):
    for i in range(psize):
        mut = np.random.binomial(size=1, n=1, p=pmu)
        if mut == 0:
            continue
        for k in range(dim):
            btm = random.randrange(1,
                                   d // 2)  # only last bits to mutate because the new number must be close to the old
            for j in range(btm):
                if np.random.binomial(size=1, n=1, p=pmu) == 0:
                    continue
                pop[i][k][d - j] = (pop[i][k][d - j] + 1) % 2
    return pop


def crossover(pairs, pop, offset):
    psize=len(pop)
    temp=0
    for i in range(pairs):
        cross = np.random.binomial(size=1, n=1, p=pcr)
        if cross == 0: continue
        par1 = pop[(2 * i+offset-2*pairs+psize)%psize]
        par2 = pop[(2 * i + 1+offset-2*pairs+psize)%psize]
        # sp is the random point where the crossover will be performed
        sp = random.randrange(d // 2, d + 1)
        child1 = []
        child2 = []

        # while
        # while -> choose if
        # k = random.randint(1,dim)

        for k in range(dim):
            child1.append(par1[k][:sp] + par2[k][sp:])
            child2.append(par2[k][:sp] + par1[k][sp:])
        pop[(1+offset+temp)%psize] = child1
        pop[(2 +offset+temp)%psize] = child2
        temp+=2
    offset=(temp+offset)%psize
    return pop,offset


def genetic_algorithm(pop):
    val = []
    min = 0;
    max = 0
    for i in pop:
        t = func(a, b, c, i, dim)
        val.append(t)
    min=np.min(val)
    max=np.max(val)
    print(np.mean(val))
    print(np.max(val))
    sum = 0
    scaval=[]
    for i in range(psize):
        scaval.append((val[i] - min) / (max - min))
        sum += val[i]
    # print(val)
    # prob = []
    # for i in range(psize):
    #     prob.append((scaval[i]) / sum)
    return pop,val,scaval


def roulette_wheel_selection(pop, val, repl, psize, offset):
    temp = random.choices(np.arange(0, psize), weights=(val), k=repl)
    tpop = []
    for i in range(repl):
        tpop.append(pop[temp[i]])

    for i in range(repl):
        pop[(i + offset) % psize] = tpop[i]
        offset = (offset + repl) % psize
    return pop, offset


                    ### MAIN ###

# initialization
dim, a, b, c, d, psize, pcr, pmu, ite, repl, pairs = user_inputs()
fifo = 0
offset = 0
pop = [[[random.randint(0, 1) for i in range(d + 1)] for j in range(dim)] for k in range(psize)]
while ite > 0:
    ite -= 1
    pop, val , scaval= genetic_algorithm(pop)
    pop,offset = roulette_wheel_selection(pop, scaval, repl, psize, offset)
    pop,offset = crossover(pairs, pop, offset)
   # pop, offset = mutation(psize, pop,offset)
pop, val,scaval =genetic_algorithm(pop)
print('final population', pop)
